#!/usr/bin/env python
"""unittest for testing hw17_1.py, for tree classes."""

import hw17_1 as tree
import unittest
import random

class TreeTest(unittest.TestCase):
    data = (('Jane Dolittle', 12, 0),
            ('Frances Jones', 4, 12),
            ('Diane Johnson', 5, 4),
            ('Judi Kades', 6, 4),
            ('Clint Dante', 7,12),
            ('Jacqueline Star', 8, 7),
            ('Lori Amde', 9, 7),
            ('Chuck Arts',10, 9),
            ('Raul Pack',11, 9))
    test_tree = tree.Tree(data)
    len_data = len(data)

    def GenerateCombos(self):
        """Yields all combinations of 2 indices into the data, except
        the combos where the indices are equal.  Also hands back
        a fresh mutable copy of the data.
        """
        for o_index in range(TreeTest.len_data):
            for i_index in range(TreeTest.len_data):
                if o_index == i_index:
                    continue
                mutable_data = self.MakeMutableData()
                yield (o_index, i_index, mutable_data)


    def MakeMutableData(self, the_data=None):
        """Return TreeTest.data as a list of lists, unless the_data
        exists, in which case it returns the_data as a list
        of lists.
        """
        if not the_data:
            the_data = TreeTest.data
        mutable_data = []
        for each in the_data:
            mutable_data += [list(each)]
        return mutable_data


    def StoreTree(self, a_tree, file_name):
        """Store the tree's data in a file in case there are
        problems, we have the original data.
        """
        file_obj = open(file_name, "w")
        file_obj.write("""
# These are data generated by hw17_2.py for finding
# problems with the classes in hw17_1.py
#
""")
        file_obj.write("data = %s" % (str(a_tree.DumpData())))
        file_obj.close()        
        

    def testBadParent(self):
        """Adding a Node with a non-existent parent."""
        parent_id = max([datum[1] for datum in self.data]) + 1
        id = parent_id + 2
        self.assertRaises(ValueError,
                          TreeTest.test_tree.AddNode,
                          name="x", id=id, parent_id=parent_id)

    def testDrawTree(self):
        """Testing that Tree.DrawTree still works on this data."""
        should_be = """Jane Dolittle:12
  Frances Jones:4
    Diane Johnson:5
    Judi Kades:6
  Clint Dante:7
    Jacqueline Star:8
    Lori Amde:9
      Chuck Arts:10
      Raul Pack:11
"""
        self.assertEquals(TreeTest.test_tree.DrawTree(), should_be)

    def testDumpData(self):
        """Testing that Tree.DumpData gives back the same data
        that initialized the tree."""
        
        dumped_data = TreeTest.test_tree.DumpData()
        self.assertEqual(self.MakeMutableData(dumped_data),
                         self.MakeMutableData())

    def testDuplicateDataLine(self):
        for o_index, i_index, mutable_data in self.GenerateCombos():
            mutable_data[o_index] = mutable_data[i_index]
            self.assertRaises(ValueError, tree.Tree, mutable_data)
                
    def testDuplicateDatum(self):
        no_dups_indices = range(len(tree.Tree.dont_duplicate))
        for no_dup_index in no_dups_indices:
            for o_index, i_index, mutable_data in self.GenerateCombos():
                mutable_data[o_index][no_dup_index] = (
                    mutable_data[i_index][no_dup_index])
                self.assertRaises(ValueError, tree.Tree, mutable_data)

    def testFinds(self):
        """Tests Tree.FindNode"""
        
        # Good finds
        for datum in TreeTest.data:
            name, id, parent_id = datum
            found = [TreeTest.test_tree.FindNode(name=name)]
            found += [TreeTest.test_tree.FindNode(id=id)]
            found += [TreeTest.test_tree.FindNode(name=name, id=id)]
            found += [TreeTest.test_tree.FindNode(name=name, id=id,
                                                 parent_id=parent_id)]
            for find in found[1:]:
                self.assertEquals(found[0], find,
                                  msg="%s != %s" % (find, found[0]))

        # Bad finds
        for o_index in range(TreeTest.len_data):
            for i_index in range(TreeTest.len_data):
                if o_index == i_index:
                    continue
                # print data[i_index][0], data[o_index][1]
                for i, attr in enumerate(('name', 'id', 'parent_id')):
                    for j, attr2 in enumerate(('name', 'id', 'parent_id')):
                        if i == j \
                               or TreeTest.data[i_index][i] \
                               == TreeTest.data[o_index][i] \
                               or TreeTest.data[i_index][j] \
                               == TreeTest.data[o_index][j]:
                            continue
                        do = "self.assertEquals(TreeTest.test_tree.FindNode(" \
                             + attr + "=TreeTest.data[i_index][i], " \
                             + attr2 + "=TreeTest.data[o_index][j]), False)"
                        exec(do)

        # testing an impossible id
        self.assertRaises(ValueError, TreeTest.test_tree.FindNode,
                          id=str(TreeTest.len_data * 12))
        # testing an impossible name
        self.assertRaises(ValueError, TreeTest.test_tree.FindNode,
                          name=str(TreeTest.len_data * 12))
        
    def testMakeDiagram(self):
        should_be = """                             12                             
              4                             7               
       5              6              8              9       
                                                10     11  
"""
        self.assertEquals(TreeTest.test_tree.MakeDiagram(60), should_be)

    def testTreeIterator(self):
        should_be = """Jane Dolittle:12
Frances Jones:4
Diane Johnson:5
Judi Kades:6
Clint Dante:7
Jacqueline Star:8
Lori Amde:9
Chuck Arts:10
Raul Pack:11
"""
        result = ""
        for node in TreeTest.test_tree:
            result += "%s \n" % node

    def testRemoveRoot(self):
        self.assertRaises(ValueError, TreeTest.test_tree.DropNode,
                          node=TreeTest.test_tree.root)

    def testTree_repr(self):
        self.assertEqual(eval('tree.' + repr(TreeTest.test_tree)),
                         TreeTest.test_tree)

    def testRandomBigTree(self, how_big=1000):

        def NameGenerator(made_so_far=[]):
            name_chars = "abcdefghijklmnopqrstuvwxyz"
            name_maker = "''.join(random.sample(name_chars, \
            random.randrange(1,20)))"
            while True:
                name = eval(name_maker)
                while name in made_so_far:
                    name = eval(name_maker)
                made_so_far += [name]
                yield name
            
        GetName = NameGenerator()

        big_tree = tree.Tree()
        parent_id = 0
        ids_to_make = range(1, how_big + 1)
        random.shuffle(ids_to_make)
        nodes_to_drop = []
        for i, id in enumerate(ids_to_make):
            name=GetName.next()
            big_tree.AddNode(name=name, id=id, parent_id=parent_id)
            if i % 10 == 1: # mark every 10th for dropping later
                nodes_to_drop += [{"name":name, "id":id,
                                   "parent_id":parent_id}]
            parent_id = random.choice(ids_to_make[:i+1])
        self.assertEqual(eval('tree.' + repr(big_tree)), big_tree)
        # Making a copy in case there are problems
        self.StoreTree(big_tree, "big_tree.py")

        # Reversing the nodes_to_drop so that we won't drop a parent
        # before we drop the child.
        for i, node in enumerate(reversed(nodes_to_drop)):
            if i % 12 == 0:
                big_tree.DropNode(name= node["name"])
            elif i % 12 == 1:
                big_tree.DropNode(id=node["id"])
            elif i % 12 == 2:
                big_tree.DropNode(name=node["name"], id=node["id"])
            elif i % 12 == 3:
                big_tree.DropNode(name=node["name"],
                                  parent_id=node["parent_id"])
            elif i % 12 == 4:
                big_tree.DropNode(parent_id=node["parent_id"],
                                  id=node["id"])
            elif i % 12 == 5:
                big_tree.DropNode(name=node["name"], id=node["id"],
                                  parent_id=node["parent_id"])
            elif i % 12 == 6:
                self.assertRaises(ValueError, big_tree.DropNode,
                                  id=node["id"],name=GetName.next())
            elif i % 12 == 7:
                self.assertRaises(ValueError, big_tree.DropNode,
                                  name=node["name"],
                                  parent_id=node["parent_id"] + 1)
            elif i % 12 == 8:
                self.assertRaises(ValueError, big_tree.DropNode,
                                  id=node["id"],
                                  parent_id=node["parent_id"] + 1)
            elif i % 12 == 9:
                self.assertRaises(ValueError, big_tree.DropNode,
                                  name=node["name"], id=node["id"] + 1)
            elif i % 12 == 10:
                self.assertRaises(AttributeError, big_tree.DropNode,
                                  parent_id=node["parent_id"])
            elif i % 12 == 11: # should work quietly
                big_tree.DropNode(parent_id=node["parent_id"],
                                  name=node["name"])
        # more bad drops
        self.assertRaises(ValueError, big_tree.DropNode, id=how_big+2)
        big_tree.DropFamily(id=big_tree.root.id)
        # Should be empty now
        self.assertEqual(big_tree, tree.Tree())

def main():
    unittest.main()    

if __name__ == '__main__':
    main()

"""
$hw17_2.py
.........
----------------------------------------------------------------------
Ran 9 tests in 1.081s

OK
$
"""
